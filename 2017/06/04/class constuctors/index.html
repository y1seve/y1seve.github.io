<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="y1seve's blog"><title>Kotlin 类构造器 | 像风一样自由</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Kotlin 类构造器</h1><a id="logo" href="/.">像风一样自由</a><p class="description">使自己变得更好</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Kotlin 类构造器</h1><div class="post-meta">Jun 4, 2017<span> | </span><span class="category"><a href="/categories/Kotlin/">Kotlin</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="类构造器"><a href="#类构造器" class="headerlink" title="类构造器"></a>类构造器</h1><p>在Java中，我们知道一个类可以声明一个或多个构造器。而Kotlin对构造器进行了区分，分为主构造器（primary constructor），和次构造器（seconday constructor)。另外，Kotlin还允许我们将一些额外的初始化逻辑放在初始化代码块（initializer blocks）中。</p>
<p>主要内容：</p>
<ul>
<li><p>主构造器，初始化代码块的使用</p>
</li>
<li><p>次构造器的使用</p>
</li>
</ul>
<h2 id="主构造器和初始化代码块"><a href="#主构造器和初始化代码块" class="headerlink" title="主构造器和初始化代码块"></a>主构造器和初始化代码块</h2><h3 id="对类声明的简单分析"><a href="#对类声明的简单分析" class="headerlink" title="对类声明的简单分析"></a>对类声明的简单分析</h3><p>下面是一个User类的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class User(val nickname: String)</div></pre></td></tr></table></figure>
<p>小括号中的代码块就是主构造器，该主构造器指定了构造器的参数，并定义了被构造器的参数初始化的属性。下面我们来慢慢对这个简短的声明进行一个分析。</p>
<p>下面的User类的声明基本和前面的User类声明一样：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> nickname: String</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        nickname = _nickname</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中有两个关键字：<code>constuctor</code>，<code>init</code>。<code>constuctor</code>表示是主构造器或者次构造器声明；<code>init</code>表示是初始化代码块声明。</p>
<p>当通过主构造器创建对象时，初始化代码块就会被执行。可以定义多个初始化代码块，执行顺序和初始化代码块的声明顺序一致。</p>
<p>初始化代码块的作用前文已说过，是执行额外的初始化逻辑。由于语法的约束，主构造器中不能有初始化代码，无法执行额外的初始化逻辑，所以这才有初始化代码块存在的意义。</p>
<p>构造器参数<code>_nickname</code>有下划线前缀是为了和属性<code>nickname</code>区分，也可以用一样的名称，不过属性名就需要<code>this</code>来区分了，这点和Java一样。</p>
<p>说明<code>this</code>和初始化代码块的执行顺序的示例代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(nickname: String) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> nickname: String</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"initializer block 0"</span>)</div><div class="line">        <span class="keyword">this</span>.nickname = nickname</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init &#123;</div><div class="line">        println(<span class="string">"initializer block 1"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    val user = User(&quot;y1seve&quot;)</div><div class="line"></div><div class="line">//    output：</div><div class="line">//    initializer block 0</div><div class="line">//    initializer block 1</div></pre></td></tr></table></figure>
<p>下面我们继续分析，注意分析对象是前文主构造器参数为<code>_nickname</code>的代码块，而不是前文的说明<code>this</code>和初始化代码块执行顺序的代码块。</p>
<p>其实我们并不需要将初始化代码放在初始化代码块中，因为这里的初始化代码<code>nickname = _nickname</code>可以和属性<code>nickname</code>的声明结合在一起；并且如果主构造器在没有注解或者修饰符修饰的情况下，也可以省略<code>constuctor</code>关键字。简化代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(_nickname: String) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">val</span> nickname = _nickname</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这又是一种声明User类的方式。需要注意的是我们是如何在属性初始化器（property initializers）和初始化代码块中引用主构造器参数的。</p>
<p>上面两种声明User类的方式在声明属性时，都是在类的内部代码块中使用<code>val</code>关键字。如果属性是由主构造器中对应的参数来初始化的，那么可以直接在该主构造器参数前加上<code>val</code>关键字即可，省略类内部代码块中的属性初始化代码。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class User(val nickname: String)</div></pre></td></tr></table></figure>
<p>上述三种声明类的方式是等同的，但是最后一种在形式上是最简洁的。</p>
<h3 id="默认构造器参数"><a href="#默认构造器参数" class="headerlink" title="默认构造器参数"></a>默认构造器参数</h3><p>类似于函数参数一样，我们可以为构造器参数声明默认参数。当然这里的参数都是指实参。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String, <span class="keyword">val</span> isSubscribed: <span class="built_in">Boolean</span> = <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="keyword">val</span> y1seve00 = User(<span class="string">"y1seve00"</span>)</div><div class="line">println(y1seve00.isSubscribed)</div><div class="line"></div><div class="line"><span class="keyword">val</span> y1seve01 = User(<span class="string">"y1seve01"</span>, <span class="literal">false</span>)</div><div class="line">println(y1seve01.isSubscribed)</div><div class="line"></div><div class="line"><span class="comment">//  output:</span></div><div class="line"><span class="comment">//  true</span></div><div class="line"><span class="comment">//  false</span></div></pre></td></tr></table></figure>
<p>如果所有的构造器参数都有默认值，那么编译器会额外生成一个空参数的构造器。通过用空参数构造器初始化类的库会更让Kotlin的使用变得更加简单。</p>
<h3 id="存在父类的情况"><a href="#存在父类的情况" class="headerlink" title="存在父类的情况"></a>存在父类的情况</h3><p>如果一个类存在父类，那么主构造器也必需初始化父类。提供构造器参数给父类即可。</p>
<p>示例如下:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwitterUser</span></span>(nickname: String) : User(nickname)</div></pre></td></tr></table></figure>
<p>对于没有声明任何一个构造器的类，会自动生成一个空的构造器。那么对于声明这种类的子类时，也必需显示地调用父类的空的构造器。</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadioButton</span> : <span class="type">Button</span></span>()</div></pre></td></tr></table></figure>
<p>如果是实现接口，那么在声明接口的实现类时，就不用在接口类后加上小括号了。因为接口是没有构造器的。</p>
<h3 id="私有构造器"><a href="#私有构造器" class="headerlink" title="私有构造器"></a>私有构造器</h3><p>如果不想让类被外面的代码初始化，那么可以将类的构造器进行私有化修饰。</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretive0</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Secretive1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>()</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中,<code>Secretive0</code>，<code>Secretive1</code>的构造器都用private修饰了，类外面的代码都无法初始化这两个类。</p>
<p><code>Secretive0</code>私有化了主构造器，<code>Secretive1</code>私有化了次构造器，关于次构造器后文会说明。</p>
<p>在Java中，我们使用私有构造器来阻止外部来初始化类，主要是要表明该类是一个单例，或者是包含很多静态工具方法的容器。但是在Kotlin中，有内置的语言功能来支持这些，你可以使用最高等级的函数（声明在类外部）来作为工具方法；可以使用<code>object</code>声明来表示单例。这些我们后面的文章都会讲到。</p>
<p>在大多数情况下，类的构造器都是很直接的：要么不包含任何参数，要么就是将参数赋值给对应的属性。这就是为什么Kotlin有主构造函数这一特征，主构造函数适用于绝大多数类。但是也有一些意外，所以Kotlin允许我们定义多个构造函数，这就是次构造函数存在的意义。</p>
<h2 id="次构造器"><a href="#次构造器" class="headerlink" title="次构造器"></a>次构造器</h2><p>Kotlin中，有多个构造器的类比Java中少的多。在Java中需要多个构造器的绝大多数情景在Kotlin中都可以通过构造器默认参数解决。</p>
<p>所以在Kotlin中尽量不要声明多个构造器，而是使用构造器默认参数来解决</p>
<p>但是仍然有需要定义多个构造器的情况。最常见的就是我们需要去继承一个框架中的类，而这个类定义了许多构造器。Android中的<code>View</code>就有多个构造器，相似的声明在Kotlin中示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(ctx: Context) &#123;</div><div class="line">        <span class="comment">// some code</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(ctx: Context, attr: AttributeSet) &#123;</div><div class="line">        <span class="comment">// some code</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类中声明了两个次构造器，没有主构造器。</p>
<p>如果要继承这个类，和Java中一样，可以使用<code>super</code>或<code>this</code>关键字来调用父类或着自身另外的构造方法。</p>
<p>示例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> : <span class="type">View &#123;</span></span></div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;</div><div class="line">          <span class="comment">// some code</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(ctx: Context, attr: AttributeSet) : <span class="keyword">super</span>(ctx, attr) &#123;</div><div class="line">          <span class="comment">// some code</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，如果一个类中既声明了主构造器和次构造器，那么次构造器都需要直接（通过<code>this</code>)或间接委托到主构造器。</p>
<p>与Java代码互相调用是次构造器主要会用到的地方。要用不同的参数列表来初始化类也需要用到次构造器。</p>
<p></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/06/04/class constuctors/" data-id="cj3ik0y800006u30d65sxjmp3" class="article-share-link">分享</a><div class="tags"><a href="/tags/Kotlin/">Kotlin</a></div><div class="post-nav"><a href="/2017/06/03/variable/" class="next">Kotlin 变量</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/math/">math</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Get-Started/" style="font-size: 15px;">Get Started</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">像风一样自由.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>